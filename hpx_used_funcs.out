setXYZ
./HpxKey.js:                spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);
./View.js:                spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);
./View.js:            spVec.setXYZ(corners[k].x, corners[k].y, corners[k].z);
calculateNSide
./View.js:        var nside = HealpixIndex.calculateNSide(3600*tileSize*resolution); // 512 = size of a "tile" image
./View.js:        // should never happen, as calculateNSide will return something <=HealpixIndex.ORDER_MAX
ang2pix_nest
./View.js:            ipixCenter = hpxIdx.ang2pix_nest(polar.theta, polar.phi);
./View.js:            ipixCenter = hpxIdx.ang2pix_nest(polar.theta, polar.phi);
nside2Npix
./HealpixCache.js:    	var npix = HealpixIndex.nside2Npix(8);
./View.js:        var npix = HealpixIndex.nside2Npix(nside);
./View.js:        var npix = HealpixIndex.nside2Npix(nside);
corners_nest
./HealpixCache.js:            corners =  hpxIdx.corners_nest(ipix, 1);
./HealpixCache.js:    HealpixCache.corners_nest = function(ipix, nside) {
./HealpixCache.js:    	return HealpixCache.hpxIdxCache.corners_nest(ipix, 1);
./HpxKey.js:            corners = HealpixCache.corners_nest(this.npix, this.nside);
./View.js:            corners = HealpixCache.corners_nest(ipix, nside);
./View.js:        var corners = HealpixCache.corners_nest(ipix, nside);
queryDisc
./View.js:            pixList = hpxIdx.queryDisc(spatialVector, radius*Math.PI/180.0, true, true);
./View.js:            pixList = hpxIdx.queryDisc(spatialVector, radius*Math.PI/180.0, true, true);
radecToPolar
./View.js:            var polar = Utils.radecToPolar(lonlat[0], lonlat[1]);
./View.js:            var polar = Utils.radecToPolar(lonlat[0], lonlat[1]);

